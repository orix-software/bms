{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BMS : bank management system","text":"<p>It's a cc65 library for Orix in order to manage bank on twilighte board.</p> <p>It only manage ram bank.</p> <p></p>"},{"location":"#versions","title":"Versions","text":"<ul> <li>2025.4 documentation</li> <li>2025.3 documentation</li> </ul>"},{"location":"2025.3/","title":"BMS : bank management system (2025.3)","text":""},{"location":"2025.3/#usage-in-c-language","title":"Usage in c language","text":"<ul> <li>void *bms_create(size_t length, unsigned char flags);</li> <li>unsigned char bms_free(bms *bms);</li> <li>unsigned int bms_seek(bms *bms, unsigned int offset, unsigned char whence);</li> <li>unsigned int bms_read_write(bms bms, unsigned int length, void data, unsigned char mode);</li> <li>unsigned char bms_error();</li> <li>unsigned char bms_version();</li> </ul>"},{"location":"2025.3/#usage-in-assembly-language","title":"Usage in assembly language","text":"<ul> <li>bms_create</li> <li>bms_free</li> <li>bms_seek</li> <li>bms_read_write</li> <li>bms_error</li> <li>bms_version</li> </ul>"},{"location":"2025.3/#examples","title":"Examples","text":"<ul> <li>Examples</li> </ul>"},{"location":"2025.3/_bms_create/","title":"void *bms_create()","text":""},{"location":"2025.3/_bms_create/#void-bms_createsize_t-length-unsigned-char-flags","title":"void *bms_create(size_t length, unsigned char flags);","text":"<p>Description</p> <p>Create slots for bank memory system. Returns NULL and store error, if something is wrong, or returns struct ptr if success</p> <p>Input</p> <ul> <li>flags (unsigned char) as FLAG_PROT_READ_WRITE</li> <li>length (long)</li> </ul>"},{"location":"2025.3/_bms_error/","title":"bms_error()","text":""},{"location":"2025.3/_bms_error/#unsigned-char-bms_error","title":"unsigned char bms_error();","text":"<p>Description</p> <p>Returns the last error code from the previous bms command</p> <p>Returns</p> <ul> <li>error code (unsigned char)</li> </ul>"},{"location":"2025.3/_bms_free/","title":"bms_free()","text":""},{"location":"2025.3/_bms_free/#unsigned-char-bms_freebms-bms","title":"unsigned char bms_free(bms *bms);","text":"<p>Input</p> <ul> <li>bms (bms *) bms struct</li> </ul>"},{"location":"2025.3/_bms_read_write/","title":"bms_read_write()","text":""},{"location":"2025.3/_bms_read_write/#unsigned-int-bms_writebms-bms-unsigned-int-length-void-data","title":"unsigned int bms_write(bms bms, unsigned int length, void data);","text":"<p>Description</p> <p>read or write data</p> <p>Input</p> <ul> <li>bms (bms *) bms struct</li> <li>data (void *) data</li> <li>length (void *) length to put or to get</li> </ul> <p>Returns</p> <ul> <li>(unsigned int) number of bytes read or written</li> </ul>"},{"location":"2025.3/_bms_seek/","title":"bms_seek()","text":""},{"location":"2025.3/_bms_seek/#unsigned-int-bms_seekbms-bms-unsigned-int-offset-unsigned-char-whence","title":"unsigned int bms_seek(bms *bms, unsigned int offset, unsigned char whence);","text":"<p>Description</p> <p>seek to offset</p> <p>Input</p> <ul> <li>bms (bms *) bms struct</li> <li>offset (unsigned int) data</li> <li>whence (unsigned char)</li> </ul> <p>Returns</p> <ul> <li>(unsigned int) result</li> </ul>"},{"location":"2025.3/_bms_version/","title":"bms_version()","text":""},{"location":"2025.3/_bms_version/#unsigned-int-bms_version","title":"unsigned int bms_version();","text":"<p>Description</p> <p>free bms</p> <p>Returns</p> <ul> <li>(unsigned int) version</li> </ul>"},{"location":"2025.3/bms_bank_restore_state/","title":"Bms bank restore state","text":""},{"location":"2025.3/bms_bank_restore_state/#bms_bank_restore_state","title":"bms_bank_restore_state","text":"<p>Description</p> <p>restore the state of the bank</p> <p>Modify</p> <ul> <li>RESB</li> <li>TR0</li> <li>TR0</li> </ul>"},{"location":"2025.3/bms_bank_save_state/","title":"Bms bank save state","text":""},{"location":"2025.3/bms_bank_save_state/#bms_bank_save_state","title":"bms_bank_save_state","text":"<p>Description</p> <p>save the state of the bank</p> <p>Modify</p> <ul> <li>RESB</li> <li>TR0</li> <li>TR0</li> </ul>"},{"location":"2025.3/bms_create/","title":"bms_create","text":""},{"location":"2025.3/bms_create/#bms_create","title":"bms_create","text":"<p>Description</p> <p>Create slots for bank memory system. Returns NULL and store error, if something is wrong, or returns struct ptr if success</p> <p>Input</p> <ul> <li>Accumulator : flags (eg : FLAG_PROT_READ_WRITE only supported)</li> <li>Y Register : low byte of the length to allocate (0 to 7)</li> <li>X Register : high byte of the length to allocate (8 to 15)</li> <li>RES : 2 bytes of the length to allocate (16 to 23)</li> </ul> <p>Modify</p> <ul> <li>RES</li> <li>TR2</li> <li>libzp</li> <li>libzp+2</li> <li>libzp+4</li> <li>libzp+5</li> </ul> <p>Returns</p> <ul> <li>Accumulator : the low ptr for bms struct it returns null ($00 in A and X)</li> <li>X Register : the low ptr for bms struct it returns null ($00 in A and X)</li> </ul> <p>Use \"BMS_CREATE length0_to_15, length16_to_31, flags\" macro in 'include/bms.mac'</p> <p>Example</p> <pre><code> lda #FLAG_PROT_READ_WRITE\n ldx #&gt;15000 ; Length : 15000\n ldy #&lt;15000\n jsr bms_create\n cmp #$00\n bne @not_null\n cpx #$00\n bne @not_null\n ; can not be allocated\n rts\n@not_null:\n ...\n</code></pre>"},{"location":"2025.3/bms_error/","title":"bms_error","text":""},{"location":"2025.3/bms_error/#bms_error","title":"bms_error","text":"<p>Description</p> <p>Returns the error code</p> <p>Returns</p> <ul> <li>Accumulator : contains the error code</li> </ul> <p>Example</p> <pre><code> jsr bms_error\n ; A contains error code\n rts\n</code></pre>"},{"location":"2025.3/bms_free/","title":"bms_free","text":""},{"location":"2025.3/bms_free/#bms_free","title":"bms_free","text":"<p>Description</p> <p>Free bms struct and liberate banks</p> <p>Input</p> <ul> <li>Accumulator : low byte of the bms struct pointer</li> <li>X Register : high byte of the bms struct pointer</li> </ul> <p>Modify</p> <ul> <li>libzp</li> <li>libzp+2</li> <li>libzp+4</li> <li>libzp+5</li> </ul> <p>Example</p> <p><pre><code> lda bms_ptr\n ldx bms_ptr + 1\n jsr bms_free\n rts\n</code></pre> Here</p>"},{"location":"2025.3/bms_read_write/","title":"bms_read_write","text":""},{"location":"2025.3/bms_read_write/#bms_read_write","title":"bms_read_write","text":"<p>Description</p> <p>read or Write bytes (TR0 and TR1 contains the data copyied from bank)</p> <p>Input</p> <ul> <li>Accumulator : contains the low ptr to the bms structure</li> <li>X Register : contains the high ptr byte to the bms structure</li> <li>Y Register : mode </li> </ul> <p>Example</p> <pre><code> ; Store size\n lda #&lt;5\n sta TR2\n lda #&gt;5\n sta TR3\n ldx #&gt;5\n ; Store ptr\n lda #&lt;str\n sta TR0\n lda #&gt;str\n sta TR1\n ldy #BMS_WRITE_MODE\n lda bms_ptr\n ldx bms_ptr + 1\n jsr bms_read_write\n rts\nstr:\n .asciiz \"hello\"\n</code></pre> <p>Description</p> <p>compute bank and set depending of the offset (bms_ptr must be set), and set current bank set</p> <p>Modify</p> <ul> <li>RESB</li> <li>TR0</li> <li>libzp</li> <li>libzp+9</li> </ul>"},{"location":"2025.3/bms_seek/","title":"bms_seek","text":""},{"location":"2025.3/bms_seek/#bms_seek","title":"bms_seek","text":"<p>Description</p> <p>Seek in the bms offset</p> <p>Input</p> <ul> <li>Accumulator : low byte of the bms struct pointer</li> <li>X Register : high byte of the bms struct pointer</li> <li>Y Register : whence </li> </ul> <p>Modify</p> <ul> <li>libzp</li> </ul> <p>Example</p> <pre><code> lda #&lt;5 ; Offset low\n sta TR0 ; Offset low\n lda #&gt;5 ; Offset high\n sta TR1 ; Offset high\n lda bms_ptr ; Offset High of bms struct\n ldx bms_ptr + 1; Offset High of bms struct\n ldy #BMS_SEEK_CUR\n jsr bms_seek\n jsr rts\n</code></pre>"},{"location":"2025.3/bms_version/","title":"bms_version","text":""},{"location":"2025.3/bms_version/#bms_version","title":"bms_version","text":"<p>Description</p> <p>returns version</p>"},{"location":"2025.3/example_create_free/","title":"Example create free","text":"CAssembly/ca65 <pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include \"bms.h\"\n\nint main() {\n    bms *bms_instance;\n    int i;\n    off_t length = 6400; // Example length\n\n    printf(\"Creating bms instance with length %ld....\\n\", length);\n    bms_instance = bms_create(length, FLAG_PROT_READ_WRITE);\n    if (bms_instance == NULL) {\n        printf(\"Failed to create bms instance\\n\");\n        return 0;\n\n    }\n    else {\n        // If we can allocate more than 16 bits, it should not work in that\n        printf(\"bms instance created successfully, it's an error.\\n\");\n        return 0;\n    }\n}\n</code></pre> <pre><code>.include \"bms.inc\"\n</code></pre>"},{"location":"2025.4/_bms_create/","title":"void *bms_create()","text":""},{"location":"2025.4/_bms_create/#void-bms_createsize_t-length-unsigned-char-flags","title":"void *bms_create(size_t length, unsigned char flags);","text":"<p>Description</p> <p>Create slots for bank memory system. Returns NULL and store error, if something is wrong, or returns struct ptr if success</p> <p>Input</p> <ul> <li>flags (unsigned char) as FLAG_PROT_READ_WRITE</li> <li>length (long)</li> </ul>"},{"location":"2025.4/_bms_error/","title":"bms_error()","text":""},{"location":"2025.4/_bms_error/#unsigned-char-bms_error","title":"unsigned char bms_error();","text":"<p>Description</p> <p>Returns the last error code from the previous bms command</p> <p>Returns</p> <ul> <li>error code (unsigned char)</li> </ul>"},{"location":"2025.4/_bms_free/","title":"bms_free()","text":""},{"location":"2025.4/_bms_free/#unsigned-char-bms_freebms-bms","title":"unsigned char bms_free(bms *bms);","text":"<p>Description</p> <p>free bms</p> <p>Input</p> <ul> <li>bms (bms *) bms struct</li> </ul>"},{"location":"2025.4/_bms_read_write/","title":"bms_read_write()","text":""},{"location":"2025.4/_bms_read_write/#unsigned-int-bms_read_writebms-bms-unsigned-int-length-void-data-unsigned-char-mode","title":"unsigned int bms_read_write(bms bms, unsigned int length, void data, unsigned char mode);","text":"<p>Description</p> <p>read or write data</p> <p>Input</p> <ul> <li>bms (bms *) bms struct</li> <li>data (void *) data</li> <li>length (void *) length to put or to get</li> </ul> <p>Returns</p> <ul> <li>(unsigned int) number of bytes read or written</li> </ul>"},{"location":"2025.4/_bms_seek/","title":"bms_seek()","text":""},{"location":"2025.4/_bms_seek/#unsigned-int-bms_seekbms-bms-unsigned-int-offset-unsigned-char-whence","title":"unsigned int bms_seek(bms *bms, unsigned int offset, unsigned char whence);","text":"<p>Description</p> <p>seek to offset</p> <p>Input</p> <ul> <li>bms (bms *) bms struct</li> <li>offset (unsigned int) data</li> <li>whence (unsigned char) (possible value : BMS_SEEK_CUR, BMS_SEEK_SET, not managed : BMS_SEEK_END,)</li> </ul> <p>Returns</p> <ul> <li>(unsigned int) result</li> </ul>"},{"location":"2025.4/_bms_version/","title":"bms_version()","text":""},{"location":"2025.4/_bms_version/#unsigned-int-bms_version","title":"unsigned int bms_version();","text":"<p>Description</p> <p>free bms</p> <p>Returns</p> <ul> <li>(unsigned int) version</li> </ul>"},{"location":"2025.4/bms_bank_restore_state/","title":"Bms bank restore state","text":""},{"location":"2025.4/bms_bank_restore_state/#bms_bank_restore_state","title":"bms_bank_restore_state","text":"<p>Description</p> <p>restore the state of the bank</p> <p>Modify</p> <ul> <li>RESB</li> <li>TR0</li> </ul>"},{"location":"2025.4/bms_bank_save_state/","title":"Bms bank save state","text":""},{"location":"2025.4/bms_bank_save_state/#bms_bank_save_state","title":"bms_bank_save_state","text":"<p>Description</p> <p>save the state of the bank</p> <p>Modify</p> <ul> <li>RESB</li> <li>TR0</li> </ul>"},{"location":"2025.4/bms_create/","title":"bms_create","text":""},{"location":"2025.4/bms_create/#bms_create","title":"bms_create","text":"<p>Description</p> <p>Create slots for bank memory system. Returns NULL and store error, if something is wrong, or returns struct ptr if success</p> <p>Input</p> <ul> <li>Accumulator : flags (eg : FLAG_PROT_READ_WRITE only supported)</li> <li>Y Register : low byte of the length to allocate (0 to 7)</li> <li>X Register : high byte of the length to allocate (8 to 15)</li> <li>RES : 2 bytes of the length to allocate (16 to 23)</li> </ul> <p>Modify</p> <ul> <li>RESModifyed also with XBANK (allocated bank id)</li> <li>TR0</li> <li>RESB</li> <li>TR0; From xmalloc</li> <li>TR1; From xmalloc</li> <li>TR2; From xmalloc</li> </ul> <p>Returns</p> <ul> <li>Accumulator : the low ptr for bms struct it returns null ($00 in A and X)</li> <li>X Register : the low ptr for bms struct it returns null ($00 in A and X)</li> </ul> <p>Use \"BMS_CREATE length0_to_15, length16_to_31, flags\" macro in 'include/bms.mac'</p> <p>Example</p> <pre><code> lda #FLAG_PROT_READ_WRITE\n ldx #&gt;15000 ; Length : 15000\n ldy #&lt;15000\n jsr bms_create\n cmp #$00\n bne @not_null\n cpx #$00\n bne @not_null\n ; can not be allocated\n rts\n@not_null:\n ...\n</code></pre>"},{"location":"2025.4/bms_error/","title":"bms_error","text":""},{"location":"2025.4/bms_error/#bms_error","title":"bms_error","text":"<p>Description</p> <p>Returns the error code</p> <p>Returns</p> <ul> <li>Accumulator : contains the error code</li> </ul> <p>Example</p> <pre><code> jsr bms_error\n ; A contains error code\n rts\n</code></pre>"},{"location":"2025.4/bms_free/","title":"bms_free","text":""},{"location":"2025.4/bms_free/#bms_free","title":"bms_free","text":"<p>Description</p> <p>Free bms struct and liberate banks</p> <p>Input</p> <ul> <li>Accumulator : low byte of the bms struct pointer</li> <li>X Register : high byte of the bms struct pointer</li> </ul> <p>Modify</p> <ul> <li>libzp</li> <li>libzp+2</li> <li>libzp+4</li> <li>libzp+5</li> </ul> <p>Example</p> <p><pre><code> lda bms_ptr\n ldx bms_ptr + 1\n jsr bms_free\n rts\n</code></pre> Here</p>"},{"location":"2025.4/bms_read_write/","title":"bms_read_write","text":""},{"location":"2025.4/bms_read_write/#bms_read_write","title":"bms_read_write","text":"<p>Description</p> <p>read or Write bytes (TR0 and TR1 contains the data copied from bank)</p> <p>Input</p> <ul> <li>Accumulator : contains the low ptr to the bms structure</li> <li>X Register : contains the high ptr byte to the bms structure</li> <li>Y Register : mode </li> </ul> <p>Modify</p> <ul> <li>RES</li> <li>TR4</li> <li>TR5</li> <li>TR6</li> <li>TR7</li> <li>libzp</li> <li>libzp+1</li> <li>libzp+2</li> <li>libzp+3</li> <li>libzp+4</li> </ul> <p>Example</p> <pre><code> ; Store size\n lda #&lt;5\n sta TR2\n lda #&gt;5\n sta TR3\n ldx #&gt;5\n ; Store ptr\n lda #&lt;str\n sta TR0\n lda #&gt;str\n sta TR1\n ldy #BMS_WRITE_MODE\n lda bms_ptr\n ldx bms_ptr + 1\n jsr bms_read_write\n rts\nstr:\n .asciiz \"hello\"\n</code></pre> <p>Description</p> <p>compute bank and set depending of the offset (bms_ptr must be set), and set current bank set * RESB * TR0 * libzp * libzp+9</p>"},{"location":"2025.4/bms_seek/","title":"bms_seek","text":""},{"location":"2025.4/bms_seek/#bms_seek","title":"bms_seek","text":"<p>Description</p> <p>Seek in the bms offset (Available : BMS_SEEK_SET, BMS_SEEK_CUR, not managed : BMS_SEEK_END)</p> <p>Input</p> <ul> <li>Accumulator : low byte of the bms struct pointer</li> <li>X Register : high byte of the bms struct pointer</li> <li>Y Register : whence </li> </ul> <p>Modify</p> <ul> <li>libzp</li> </ul> <p>Example</p> <pre><code> lda #&lt;5 ; Offset low\n sta TR0 ; Offset low\n lda #&gt;5 ; Offset high\n sta TR1 ; Offset high\n lda bms_ptr ; Offset High of bms struct\n ldx bms_ptr + 1; Offset High of bms struct\n ldy #BMS_SEEK_CUR\n jsr bms_seek\n jsr rts\n</code></pre>"},{"location":"2025.4/bms_version/","title":"bms_version","text":""},{"location":"2025.4/bms_version/#bms_version","title":"bms_version","text":"<p>Description</p> <p>returns version</p>"},{"location":"2025.4/example_create_free/","title":"Examples","text":""},{"location":"2025.4/example_create_free/#free-sample","title":"Free sample","text":"CAssembly/ca65 <pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include \"bms.h\"\n\nint main() {\n    bms *bms_instance;\n    int i;\n    off_t length = 6400; // Example length\n\n    printf(\"Creating bms instance with length %ld....\\n\", length);\n    bms_instance = bms_create(length, FLAG_PROT_READ_WRITE);\n    if (bms_instance == NULL) {\n        printf(\"Failed to create bms instance\\n\");\n        return 0;\n\n    }\n    else {\n        // If we can allocate more than 16 bits, it should not work in that\n        printf(\"bms instance created successfully, it's an error.\\n\");\n        return 0;\n    }\n}\n</code></pre> <pre><code>.include \"bms.inc\"\n</code></pre>"},{"location":"2025.4/example_create_free/#include","title":"include","text":""},{"location":"2025.4/example_create_free/#include_1","title":"include","text":""},{"location":"2025.4/example_create_free/#include_2","title":"include","text":""},{"location":"2025.4/example_create_free/#include-bmsh","title":"include \"bms.h\"","text":"<p>int convert_bms_error_into_string(unsigned char errorcode) {     printf(\"Error : \");     switch (errorcode) {</p> <pre><code>    case  BMS_EOK:\n       puts(\"EOK\");\n        /* code */\n       break;\n\n    case BMS_EBANK_FULL:\n        puts(\"BMS_EBANK_FULL\");\n        /* code */\n        break;\n\n    case BMS_CAN_NOT_RUN_INTO_BANK:\n        puts(\"BMS_CAN_NOT_RUN_INTO_BANK\");\n        /* code */\n        break;\n\n    case BMS_LENGTH_REQUESTED_TOO_LONG:\n        puts(\"BMS_LENGTH_REQUESTED_TOO_LONG\");\n        /* code */\n        break;\n\n    default:\n        printf(\"Error code unknown\");\n        break;\n}\n</code></pre> <p>}</p>"},{"location":"2025.4/example_create_free/#full-example","title":"Full example","text":"C <p>int main() {     bms bms_instance;     int i;     off_t length = 640000; // Example length     char str_hello = \"Hello World\";     unsigned char *verify = \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\";     // Create a new bms instance     //memset(verify, 'A', sizeof(verify));     // for (i = 0; i &lt; 16501; i++) {     //     verify[i] = 'A';     // }</p> <pre><code>printf(\"Creating bms instance with length %ld....\\n\", length);\nbms_instance = bms_create(length, FLAG_PROT_READ_WRITE);\nif (bms_instance == NULL) {\n    printf(\"Failed to create bms instance\\n\");\n    convert_bms_error_into_string(bms_error());\n\n}\nelse {\n    // If we can allocate more than 16 bits, it should not work in that\n    printf(\"bms instance created successfully, it's an error.\\n\");\n    convert_bms_error_into_string(bms_error());\n    return 1;\n}\n\nlength = 64000;\nprintf(\"Creating bms instance with length %ld....\\n\", length);\nbms_instance = bms_create(length, FLAG_PROT_READ_WRITE);\nif (bms_instance == NULL) {\n    convert_bms_error_into_string(bms_error());\n}\nelse {\n    printf(\"bms instance created successfully, it's an error.\\n\");\n    convert_bms_error_into_string(bms_error());\n    return 1;\n}\n\nlength = 6400;\nprintf(\"Creating bms instance with length %ld....\\n\", length);\nbms_instance = bms_create(length, FLAG_PROT_READ_WRITE);\nif (bms_instance == NULL) {\n    printf(\"bms instance did not created successfully, it's an error.\\n\");\n    convert_bms_error_into_string(bms_error());\n    return 1;\n}\nelse {\n    printf(\"bms instance created successfully.\\n\");\n    convert_bms_error_into_string(bms_error());\n}\n\nif (bms_instance-&gt;number_of_banks != 1 ) {\n    printf(\"Error: Expected 1 banks, but got %d\\n\", bms_instance-&gt;number_of_banks);\n    bms_free(bms_instance);\n    return 1;\n}\n\n// Bank %d: set=%d, bank_register=%d,\nputs(\"+-------------------------------------+\");\nputs(\"| slot|set|breg|bid|lbounds|hbounds   |\");\nputs(\"+-------------------------------------+\");\n\nfor (i = 0; i &lt; bms_instance-&gt;number_of_banks; i++) {\n    printf(\"|%d    | %d |  %d |%d |     %u | %u    |\\n\",\n            i,\n            bms_instance-&gt;set[i],\n            bms_instance-&gt;bank_register[i],\n            bms_instance-&gt;bankid[i],\n            bms_instance-&gt;lboundaries[i],\n            bms_instance-&gt;hboundaries[i]);\n}\n\nputs(\"+-------------------------------------+\");\nprintf(\"Number of banks : %d\\n\", bms_instance-&gt;number_of_banks);\nputs(\"Writing ...\");\nbms_read_write(bms_instance, 11, str_hello, BMS_WRITE_MODE);\n// bms_read_write(bms_instance, 5, str_hello, BMS_WRITE_MODE);\nbms_seek(bms_instance, 3, BMS_SEEK_SET);\nbms_read_write(bms_instance, 9, verify, BMS_READ_MODE);\nprintf(\"Verify : %s\\n\", verify);\nbms_seek(bms_instance, 0, BMS_SEEK_SET);\nbms_seek(bms_instance, 2, BMS_SEEK_CUR);\nbms_read_write(bms_instance, 8, verify, BMS_READ_MODE);\nprintf(\"Verify : %s\\n\", verify);\n// // // Free the bms instance\nbms_free(bms_instance);\n\n// return 0;\n</code></pre>"},{"location":"2025.4/example_create_free/#_1","title":"}","text":""}]}